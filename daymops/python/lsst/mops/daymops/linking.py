"""
General linking routines and constants.

This should really be part of a library or separate module. You will find 
funtions that link DIASources into Tracklets, Tracklets into Tracks and then 
into full Orbits.

This modules uses OpenOrb wrappers (oorb module) as well as Auton wrappers 
(auton module).
"""
import random
import warnings

import lib
import DiaSourceList
import Orbit
from Tracklet import Tracklet

# import fake_auton as auton
import auton

import numpy
import oorb


# Constants
DEFAULT_MAXV = 2.0                # upper velocity cut (deg/day)
DEFAULT_MINOBS = 2                # min DIASources/tracklet
DEFAULT_MAXOBS = None             # max DIASources/tracklet
DEFAULT_EXTENDED = False          # use trail info when available?
DEFAULT_MAXT = 0.05               # max tracklet time length (day)
DEFAULT_EXPTIME = 15.             # image exposure time (s)
DEFAULT_COLLAPSE_ARGS = '0.002 0.002 5.0 0.05' # collapseTracklets arguments.


def trackletsFromDiaSources(sources, maxV=DEFAULT_MAXV, minObs=DEFAULT_MINOBS, 
                            maxT=DEFAULT_MAXT, expTime=DEFAULT_EXPTIME, 
                            useTrailData=DEFAULT_EXTENDED):
    """
    Form Tracklets form DIASources by using auton.findTracklets.
    
    @param sources: a simple list of DIASource attributes (see below).
    @param maxV: value of the maxv parameter for findTracklets (see below).
    @param minObs: value of the minobs parameter for findTracklets (see below).
    @param maxT: value of the maxt parameter for findTracklets (see below).
    @param expTime: value of the etime parameter for findTracklets (see below).
    @param useTrailData: value of the extended parameter for findTracklets (see 
           below).
    
    Return
        Iterator to the list of Tracklet instances generated by findTracklets.
    
    Notes
    sources has the form
        [[id, mjd, ra, dec, mag, obscode, objName, trailLength, trailAngle], ]
    with each element corresponding to the attributes of a single DIASource.
    
    For the findTracklets-specific parameters (e.g. maxv etc.), please refer to 
    the findTracklets documentation.
    """
    # dets is [id, mjd, ra, dec, mag, obscode, objName, trailLength, trailAngle]
    dets = [(d.getDiaSourceId(),
             d.getTaiMidPoint(),
             d.getRa(),
             d.getDec(),
             lib.fluxToMag(d.getApFlux(), d.getApFluxErr(), d.getRefMag())[0],
             d.getObsCode(),
             str(d.getDiaSourceId()),
             0.,
             0.) for d in sources]
    
    # Build a dictionary so that given a diaSourceId we can fetch the 
    # corresponding DiaSource instance.
    idDict = dict([(d.getDiaSourceId(), d) for d in sources])
    
    # TODO: compute and use trail information!
    # TODO: Support per-DIASource exposure time.
    # TODO: Use fluxes instead of mags.
    trackletToDiaSourceId = auton.findtracklets(detections=dets, 
                                                maxv=maxV,
                                                minobs=int(minObs),
                                                maxt=maxT,
                                                etime=expTime)
    
    # Create Tracklet instances and return an iterator to the full list.
    # tracklets = [Tracklet(diaSources=[idDict[_id] for _id in ids]) \
    #              for ids in trackletToDiaSourceId]
    for ids in trackletToDiaSourceId:
        t = Tracklet(diaSources=[idDict[_id] for _id in ids])
        if(not t._diaSources):
            raise(Exception('Empty tracklet!'))
        yield(t)
    # return(tracklets)


def linkTracklets(tracklets, slowMinV, slowMaxV, slowVtreeThresh,slowPredThresh,
                  fastMinV, fastMaxV, fastVtreeThresh, fastPredThresh,minNights,
                  plateWidth):
    """
    Given a list of tracklets, link them into tracks. Do two passes: one for 
    slow movers (defined as having velocity between slowMinV and slowMaxV) and
    one for fast movers (defined as having velocity between fastMinV and 
    fastMaxV).
    
    @param tracklets: list of Tracklet instances.
    @param slowMinV: linkTracklet specific.
    @param slowMaxV: linkTracklet specific.
    @param slowVtreeThresh: linkTracklet specific.
    @param slowPredThresh: linkTracklet specific.
    @param fastMinV: linkTracklet specific.
    @param fastMaxV: linkTracklet specific.
    @param fastVtreeThresh: linkTracklet specific.
    @param fastPredThresh: linkTracklet specific.
    @param minNights: linkTracklet specific.
    @param plateWidth: linkTracklet specific.
    
    Return 
    Iterator to flattened list of lists of Tracklet IDs. Each sub-list 
    corresponds to a track:
        [[trackletId1, trackletId2, ...], ...]
    
    Notes
    For the linkTracklets-specific parameters (e.g. slowMinV etc.), please refer
    to the linkTracklets documentation.
    """
    dets = []
    for t in tracklets:
        trackletId = t.getTrackletId()
        
        # Convert fluxes to mags.
        for d in t.getDiaSources():
            mag, magErr = lib.fluxToMag(d.getApFlux(), 
                                        d.getApFluxErr(), 
                                        d.getRefMag())
            dets.append((trackletId,
                         d.getTaiMidPoint(),
                         d.getRa(),
                         d.getDec(),
                         mag,
                         int(d.getObsCode()),
                         'dummy'))
    
    # Set basic linkTracklets options.
    args = {'detections': dets,
            'min_obs': minNights * 2,
            'min_sup': minNights,
            'plate_width': plateWidth}
    
    # Get the slow tracks.
    args.update({'minv': slowMinV,
                 'maxv': slowMaxV,
                 'vtree_thresh': slowVtreeThresh,
                 'pred_thresh': slowPredThresh})
    rawTracks = auton.linktracklets(**args)
    
    # Get the fast tracks.
    args.update({'minv': fastMinV,
                 'maxv': fastMaxV,
                 'vtree_thresh': fastVtreeThresh,
                 'pred_thresh': fastPredThresh})
    rawTracks += auton.linktracklets(**args)
    
    # What we get from linkTracklets is simply a list of list of trackletIds:
    #   [[trackletId1, trackletId2, ...], ...]
    for t in rawTracks:
        yield(t)
    # return(rawTracks)


def orbitDetermination(track, 
                       elementType='keplerian', 
                       numRangingOrbits=5000,
                       stdDev=8.3333333333333331e-05,
                       obscode='566'):
    """
    Given a Track instance, determine one or zero orbits for this Track and 
    return
        orbit|None
    meaning we either have an orbit or None.
    
    @param track: a Track instance.
    @param elementType: name of the orbital element type to use.
    @param numRangingOrbits: number of ranging orbits to produce.
    @param stdDev: observational RA/Dec uncertainty in degrees.
    
    Return
    Orbit|None
    
    Notes
    If orbit determination fails for a given Track (and it will, most of the 
    time as most Tracks are non valid orbits), return None.
    """
    # We do statistical ranging first. Then we do LSL on the orbits we get from 
    # statistical ranging.
    trackId = track.getTrackId()
    coords = []
    mjds = []
    mags = []
    filters = []
    obscodes = []                           # In reality we only have one!
    
    # Get to the DiaSources.
    for tracklet in track.getTracklets():
        for d in tracklet.getDiaSources():
            coords.append([d.getRa(), stdDev, d.getDec(), stdDev])
            mags.append(lib.fluxToMag(d.getApFlux(), 
                                      d.getApFluxErr(), 
                                      d.getRefMag()))
            mjds.append(d.getTaiMidPoint())
            # TODO: do we need the filter name or is the ID string OK?
            filters.append(str(d.getFilterId()))
    
    # Now convert those to numpy arrays.
    coords = numpy.array(coords, dtype='d')
    coords.shape = (len(coords), 4)
    obscodes = [obscode, ] * len(mjds)
    mjds = numpy.array(mjds, dtype='d')
    mags = numpy.array(mags, dtype='d')
    
    # We can start statistical ranging.
    try:
        # Choose just 3 or 4 detections for ranging.
        rangingOrbits = oorb.ranging_fast(trackId=trackId,
                                          coords=coords[:3],
                                          mjds=mjds[:3],
                                          mags=mags[:3],
                                          obscodes=obscodes[:3],
                                          filters=filters[:3],
                                          elementType=elementType,
                                          numOrbits=numRangingOrbits)

        # Now pass them to LSL and this time use all detections.
        # res = (out_orbit, out_covariance, out_sigmas, out_correlation)
        res = oorb.lsl_fast(trackId=trackId,
                            coords=coords,
                            mjds=mjds,
                            mags=mags,
                            obscodes=obscodes,
                            filters=filters,
                            rangingOrbits=rangingOrbits)
    except:
        # Orbit determination failed for this track. Oh well.
        return(None)
    
    # If everything went well, we have an orbit with covariance.
    # res[0]: [a, e, i, node, argPeri, m, epoch, H, G, elTypeId]
    # res[1]: is a 6x6 covariance matrix, get the diagonal form.
    cov = []
    for i in (0, 1, 2, 3, 4, 5):
        for j in range(i):
            cov.append(res[1][i][j])
    # q = (1 - e) * a
    return(Orbit.Orbit(q=(1. - res[0][1]) * res[0][0],
                       e=res[0][1],
                       i=res[0][2],
                       node=res[0][3],
                       argPeri=res[0][4],
                       m=res[0][5],
                       epoch=res[0][6],
                       src=cov))
    
    
def chooseOrbit(movingObjects):
    """
    Given a list of MovingObject instances (presumably associated to the same
    Tracklet instance), choose one.
    
    Now, the way to choose one out of many is up for debate and is a scientific
    question, not a technical one. Also, do we need to choose? Can we live with
    multiple MovingObjects per Tracklet? Probably we should, actually.
    
                    "Ai posteri l'ardua sentenza" A. Manzoni
    """
    # Be obnoxious so that people actually do something about this :-)
    warnings.warn('chooseOrbit() needs to be properly thought out!')
    
    # And, to make it clear that we are not kidding, just return a random 
    # object.
    return(movingObjects[int(round(random.random()*(len(movingObjects)-1)))])
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    